do_conformal_conditional <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
library(reticulate)
source_python("~/repositories/conformal/Python/condconf.py")
source_python("~/repositories/conformal/Python/crossval.py")
out <- run_fun(as.matrix(X_cal), as.matrix(Y_cal),  x_test = as.matrix(X_test), predictor = predictor, alpha = alpha)
cf_preds <- as.data.table(do.call(cbind, out))
names(cf_preds) <- c("lower", "upper", "f")
cf_preds <- cf_preds[, c("f", "lower", "upper"), with = FALSE]
cf_preds$width <- cf_preds$upper - cf_preds$lower
return(cf_preds)
}
do_conformal_marginal <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
if(!require(conformalInference)) {
devtools::install_github(repo="ryantibs/conformal", subdir="conformalInference")
}
X_cal_tmp <- rbind(X_cal[1, drop = FALSE], X_cal)
Y_cal_tmp <- c(Y_cal[1], Y_cal)
out <- conformalInference::conformal.pred.split(
x = X_cal_tmp,
y = Y_cal_tmp,
x0 = as.matrix(X_test),
rho = 1/nrow(X_cal_tmp),
split = 1,
alpha = alpha,
train.fun = function(x, y) {
return(NULL)
},
predict.fun = function(out, newx){
predictor(newx)
}
)
cf_preds <- data.table(f = as.vector(out$pred), lower = as.vector(out$lo), upper = as.vector(out$up))
cf_preds$width = cf_preds$upper - cf_preds$lower
return(cf_preds)
}
# parameters
d <- 1 # covariate dimension
alpha <- 0.1 # coverage probability
lrnr <- Lrnr_gam$new()
# get data splits
data_list <- generate_data_splits(2000, 300, 100, d = d)
data_train <- data_list$data_train; data_cal <- data_list$data_cal; data_test <- data_list$data_test
X_train <- data_train$X; X_cal <- data_cal$X; X_test <- data_test$X
Y_train <- data_train$Y; Y_cal <- data_cal$Y; Y_test <- data_test$Y
# get predictor using learning algorithm specified by lrnr
predictor <- train_predictor(X_train, Y_train, lrnr)
#
preds_bin <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = binning_calibrator, nbin = 5)
preds_iso <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = iso_calibrator)
preds_cond <- do_conformal_conditional(X_cal, Y_cal, X_test, predictor, alpha = alpha)
preds_marg <- do_conformal_marginal(X_cal, Y_cal, X_test, predictor, alpha = alpha)
reticulate::source_python('~/repositories/conformal/Python/crossval.py')
library(data.table)
generate_data <- function(n, d = 5, ...) {
# covariates
X <- as.matrix(replicate(d, runif(n, 0, 1)))
colnames(X) <- paste0("X", 1:d)
# biomarker mean and variance
mu <-    rowMeans(X + sin(4*X))
sigma2 <- mu^2/4
# biomarker
Y <- rnorm(n, mu, sigma2)
median(Y)
plot(mu, Y)
plot(mu, sqrt(sigma2))
# potential outcomes being indicator of death
thresh <- 0.75
eta <-  -3 + 2*rowMeans(sqrt(X) + cos(4*sqrt(X)))
# treated, treating helps so long as blood-pressure is above threshold.
Z1 <- rbinom(n, 1, plogis(eta + 0.1*Y + (0.9*Y + 1)*(Y <= thresh)))
# untreated, high blood pressure and not treating is bad
Z0 <- rbinom(n, 1, plogis(eta + Y ))
data <- list(X=X, Y = Y, Z1 = Z1, Z0 = Z0, mu = mu, sigma2 = sigma2)
return(data)
#c(mean(Z1[Y <= thresh]), mean(Z1[Y > thresh]))
#c(mean(Z0[Y <= thresh]), mean(Z0[Y > thresh]))
#mean(Z1- Z0)
}
generate_data_splits <- function(n_train, n_cal, n_test, ...) {
data_train <- generate_data(n_train, ...)
data_cal <- generate_data(n_cal, ...)
data_test <-generate_data(n_test, ...)
return(list(data_train = data_train, data_cal = data_cal, data_test = data_test))
}
train_predictor <- function(X, Y, lrnr) {
data_train <- data.table(X,Y)
name_Y <- names(data_train)[ncol(data_train)]
covariates <- names(data_train)[-ncol(data_train)]
task <- sl3_Task$new(data_train, covariates = covariates, outcome = name_Y)
lrnr_trained <- lrnr$train(task)
predictor <- function(x) {
dat <- as.data.table(x)
names(dat) <- covariates
task <- sl3_Task$new(dat, covariates = covariates, outcome = c())
preds <- lrnr_trained$predict(task)
return(as.matrix(preds))
}
return(predictor)
}
do_conformal_calibration <- function(X_cal, Y_cal, X_test, predictor, alpha, calibrator, ...) {
f_cal <- predictor(X_cal)
f_test <- predictor(X_test)
out <- conformal_calibrator(f_train = f_cal, Y_train = Y_cal, calibrator = calibrator, alpha = alpha, ...)
cf_preds <- conformal_predict(out, f_test)
cf_preds$width <- cf_preds$upper - cf_preds$lower
cf_preds$f <- cf_preds$f_cal
cf_preds <- cf_preds[, c("f", "lower", "upper"), with = FALSE]
cf_preds$width <- cf_preds$upper - cf_preds$lower
return(cf_preds)
}
do_conformal_conditional <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
library(reticulate)
source_python("~/repositories/conformal/Python/condconf.py")
source_python("~/repositories/conformal/Python/crossval.py")
out <- run_fun(as.matrix(X_cal), as.matrix(Y_cal),  x_test = as.matrix(X_test), predictor = predictor, alpha = alpha)
cf_preds <- as.data.table(do.call(cbind, out))
names(cf_preds) <- c("lower", "upper", "f")
cf_preds <- cf_preds[, c("f", "lower", "upper"), with = FALSE]
cf_preds$width <- cf_preds$upper - cf_preds$lower
return(cf_preds)
}
do_conformal_marginal <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
if(!require(conformalInference)) {
devtools::install_github(repo="ryantibs/conformal", subdir="conformalInference")
}
X_cal_tmp <- rbind(X_cal[1, drop = FALSE], X_cal)
Y_cal_tmp <- c(Y_cal[1], Y_cal)
out <- conformalInference::conformal.pred.split(
x = X_cal_tmp,
y = Y_cal_tmp,
x0 = as.matrix(X_test),
rho = 1/nrow(X_cal_tmp),
split = 1,
alpha = alpha,
train.fun = function(x, y) {
return(NULL)
},
predict.fun = function(out, newx){
predictor(newx)
}
)
cf_preds <- data.table(f = as.vector(out$pred), lower = as.vector(out$lo), upper = as.vector(out$up))
cf_preds$width = cf_preds$upper - cf_preds$lower
return(cf_preds)
}
# parameters
d <- 1 # covariate dimension
alpha <- 0.1 # coverage probability
lrnr <- Lrnr_gam$new()
# get data splits
data_list <- generate_data_splits(2000, 300, 100, d = d)
data_train <- data_list$data_train; data_cal <- data_list$data_cal; data_test <- data_list$data_test
X_train <- data_train$X; X_cal <- data_cal$X; X_test <- data_test$X
Y_train <- data_train$Y; Y_cal <- data_cal$Y; Y_test <- data_test$Y
# get predictor using learning algorithm specified by lrnr
predictor <- train_predictor(X_train, Y_train, lrnr)
#
preds_bin <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = binning_calibrator, nbin = 5)
preds_iso <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = iso_calibrator)
preds_cond <- do_conformal_conditional(X_cal, Y_cal, X_test, predictor, alpha = alpha)
preds_marg <- do_conformal_marginal(X_cal, Y_cal, X_test, predictor, alpha = alpha)
library(sl3)
library(data.table)
library(data.table)
library(sl3)
generate_data <- function(n, d = 5, ...) {
# covariates
X <- as.matrix(replicate(d, runif(n, 0, 1)))
colnames(X) <- paste0("X", 1:d)
# biomarker mean and variance
mu <-    rowMeans(X + sin(4*X))
sigma2 <- mu^2/4
# biomarker
Y <- rnorm(n, mu, sigma2)
median(Y)
plot(mu, Y)
plot(mu, sqrt(sigma2))
# potential outcomes being indicator of death
thresh <- 0.75
eta <-  -3 + 2*rowMeans(sqrt(X) + cos(4*sqrt(X)))
# treated, treating helps so long as blood-pressure is above threshold.
Z1 <- rbinom(n, 1, plogis(eta + 0.1*Y + (0.9*Y + 1)*(Y <= thresh)))
# untreated, high blood pressure and not treating is bad
Z0 <- rbinom(n, 1, plogis(eta + Y ))
data <- list(X=X, Y = Y, Z1 = Z1, Z0 = Z0, mu = mu, sigma2 = sigma2)
return(data)
#c(mean(Z1[Y <= thresh]), mean(Z1[Y > thresh]))
#c(mean(Z0[Y <= thresh]), mean(Z0[Y > thresh]))
#mean(Z1- Z0)
}
generate_data_splits <- function(n_train, n_cal, n_test, ...) {
data_train <- generate_data(n_train, ...)
data_cal <- generate_data(n_cal, ...)
data_test <-generate_data(n_test, ...)
return(list(data_train = data_train, data_cal = data_cal, data_test = data_test))
}
train_predictor <- function(X, Y, lrnr) {
data_train <- data.table(X,Y)
name_Y <- names(data_train)[ncol(data_train)]
covariates <- names(data_train)[-ncol(data_train)]
task <- sl3_Task$new(data_train, covariates = covariates, outcome = name_Y)
lrnr_trained <- lrnr$train(task)
predictor <- function(x) {
dat <- as.data.table(x)
names(dat) <- covariates
task <- sl3_Task$new(dat, covariates = covariates, outcome = c())
preds <- lrnr_trained$predict(task)
return(as.matrix(preds))
}
return(predictor)
}
do_conformal_calibration <- function(X_cal, Y_cal, X_test, predictor, alpha, calibrator, ...) {
f_cal <- predictor(X_cal)
f_test <- predictor(X_test)
out <- conformal_calibrator(f_train = f_cal, Y_train = Y_cal, calibrator = calibrator, alpha = alpha, ...)
cf_preds <- conformal_predict(out, f_test)
cf_preds$width <- cf_preds$upper - cf_preds$lower
cf_preds$f <- cf_preds$f_cal
cf_preds <- cf_preds[, c("f", "lower", "upper"), with = FALSE]
cf_preds$width <- cf_preds$upper - cf_preds$lower
return(cf_preds)
}
do_conformal_conditional <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
library(reticulate)
source_python("~/repositories/conformal/Python/condconf.py")
source_python("~/repositories/conformal/Python/crossval.py")
out <- run_fun(as.matrix(X_cal), as.matrix(Y_cal),  x_test = as.matrix(X_test), predictor = predictor, alpha = alpha)
cf_preds <- as.data.table(do.call(cbind, out))
names(cf_preds) <- c("lower", "upper", "f")
cf_preds <- cf_preds[, c("f", "lower", "upper"), with = FALSE]
cf_preds$width <- cf_preds$upper - cf_preds$lower
return(cf_preds)
}
do_conformal_marginal <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
if(!require(conformalInference)) {
devtools::install_github(repo="ryantibs/conformal", subdir="conformalInference")
}
X_cal_tmp <- rbind(X_cal[1, drop = FALSE], X_cal)
Y_cal_tmp <- c(Y_cal[1], Y_cal)
out <- conformalInference::conformal.pred.split(
x = X_cal_tmp,
y = Y_cal_tmp,
x0 = as.matrix(X_test),
rho = 1/nrow(X_cal_tmp),
split = 1,
alpha = alpha,
train.fun = function(x, y) {
return(NULL)
},
predict.fun = function(out, newx){
predictor(newx)
}
)
cf_preds <- data.table(f = as.vector(out$pred), lower = as.vector(out$lo), upper = as.vector(out$up))
cf_preds$width = cf_preds$upper - cf_preds$lower
return(cf_preds)
}
# parameters
d <- 1 # covariate dimension
alpha <- 0.1 # coverage probability
lrnr <- Lrnr_gam$new()
# get data splits
data_list <- generate_data_splits(2000, 300, 100, d = d)
data_train <- data_list$data_train; data_cal <- data_list$data_cal; data_test <- data_list$data_test
X_train <- data_train$X; X_cal <- data_cal$X; X_test <- data_test$X
Y_train <- data_train$Y; Y_cal <- data_cal$Y; Y_test <- data_test$Y
# get predictor using learning algorithm specified by lrnr
predictor <- train_predictor(X_train, Y_train, lrnr)
#
preds_bin <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = binning_calibrator, nbin = 5)
preds_iso <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = iso_calibrator)
preds_cond <- do_conformal_conditional(X_cal, Y_cal, X_test, predictor, alpha = alpha)
preds_marg <- do_conformal_marginal(X_cal, Y_cal, X_test, predictor, alpha = alpha)
preds_bin$method <- "binning"
preds_iso$method <- "isotonic"
preds_cond$method <- "conditional"
preds_marg$method <- "marginal"
library(data.table)
library(sl3)
generate_data <- function(n, d = 5, ...) {
# covariates
X <- as.matrix(replicate(d, runif(n, 0, 1)))
colnames(X) <- paste0("X", 1:d)
# biomarker mean and variance
mu <-    rowMeans(X + sin(4*X))
sigma2 <- mu^2/4
# biomarker
Y <- rnorm(n, mu, sigma2)
median(Y)
plot(mu, Y)
plot(mu, sqrt(sigma2))
# potential outcomes being indicator of death
thresh <- 0.75
eta <-  -3 + 2*rowMeans(sqrt(X) + cos(4*sqrt(X)))
# treated, treating helps so long as blood-pressure is above threshold.
Z1 <- rbinom(n, 1, plogis(eta + 0.1*Y + (0.9*Y + 1)*(Y <= thresh)))
# untreated, high blood pressure and not treating is bad
Z0 <- rbinom(n, 1, plogis(eta + Y ))
data <- list(X=X, Y = Y, Z1 = Z1, Z0 = Z0, mu = mu, sigma2 = sigma2)
return(data)
#c(mean(Z1[Y <= thresh]), mean(Z1[Y > thresh]))
#c(mean(Z0[Y <= thresh]), mean(Z0[Y > thresh]))
#mean(Z1- Z0)
}
generate_data_splits <- function(n_train, n_cal, n_test, ...) {
data_train <- generate_data(n_train, ...)
data_cal <- generate_data(n_cal, ...)
data_test <-generate_data(n_test, ...)
return(list(data_train = data_train, data_cal = data_cal, data_test = data_test))
}
train_predictor <- function(X, Y, lrnr) {
data_train <- data.table(X,Y)
name_Y <- names(data_train)[ncol(data_train)]
covariates <- names(data_train)[-ncol(data_train)]
task <- sl3_Task$new(data_train, covariates = covariates, outcome = name_Y)
lrnr_trained <- lrnr$train(task)
predictor <- function(x) {
dat <- as.data.table(x)
names(dat) <- covariates
task <- sl3_Task$new(dat, covariates = covariates, outcome = c())
preds <- lrnr_trained$predict(task)
return(as.matrix(preds))
}
return(predictor)
}
do_conformal_calibration <- function(X_cal, Y_cal, X_test, predictor, alpha, calibrator, ...) {
f_cal <- predictor(X_cal)
f_test <- predictor(X_test)
out <- conformal_calibrator(f_train = f_cal, Y_train = Y_cal, calibrator = calibrator, alpha = alpha, ...)
cf_preds <- conformal_predict(out, f_test)
cf_preds$width <- cf_preds$upper - cf_preds$lower
cf_preds$f <- cf_preds$f_cal
cf_preds <- cf_preds[, c("f", "lower", "upper"), with = FALSE]
cf_preds$width <- cf_preds$upper - cf_preds$lower
return(cf_preds)
}
do_conformal_conditional <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
library(reticulate)
source_python("~/repositories/conformal/Python/condconf.py")
source_python("~/repositories/conformal/Python/crossval.py")
out <- run_fun(as.matrix(X_cal), as.matrix(Y_cal),  x_test = as.matrix(X_test), predictor = predictor, alpha = alpha)
cf_preds <- as.data.table(do.call(cbind, out))
names(cf_preds) <- c("lower", "upper", "f")
cf_preds <- cf_preds[, c("f", "lower", "upper"), with = FALSE]
cf_preds$width <- cf_preds$upper - cf_preds$lower
return(cf_preds)
}
do_conformal_marginal <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
if(!require(conformalInference)) {
devtools::install_github(repo="ryantibs/conformal", subdir="conformalInference")
}
X_cal_tmp <- rbind(X_cal[1, drop = FALSE], X_cal)
Y_cal_tmp <- c(Y_cal[1], Y_cal)
out <- conformalInference::conformal.pred.split(
x = X_cal_tmp,
y = Y_cal_tmp,
x0 = as.matrix(X_test),
rho = 1/nrow(X_cal_tmp),
split = 1,
alpha = alpha,
train.fun = function(x, y) {
return(NULL)
},
predict.fun = function(out, newx){
predictor(newx)
}
)
cf_preds <- data.table(f = as.vector(out$pred), lower = as.vector(out$lo), upper = as.vector(out$up))
cf_preds$width = cf_preds$upper - cf_preds$lower
return(cf_preds)
}
# parameters
d <- 1 # covariate dimension
alpha <- 0.1 # coverage probability
lrnr <- Lrnr_gam$new()
# get data splits
data_list <- generate_data_splits(2000, 300, 100, d = d)
data_train <- data_list$data_train; data_cal <- data_list$data_cal; data_test <- data_list$data_test
X_train <- data_train$X; X_cal <- data_cal$X; X_test <- data_test$X
Y_train <- data_train$Y; Y_cal <- data_cal$Y; Y_test <- data_test$Y
# get predictor using learning algorithm specified by lrnr
predictor <- train_predictor(X_train, Y_train, lrnr)
#
preds_bin <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = binning_calibrator, nbin = 5)
preds_iso <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = iso_calibrator)
preds_cond <- do_conformal_conditional(X_cal, Y_cal, X_test, predictor, alpha = alpha)
preds_marg <- do_conformal_marginal(X_cal, Y_cal, X_test, predictor, alpha = alpha)
preds_bin$method <- "binning"
preds_iso$method <- "isotonic"
preds_cond$method <- "conditional"
preds_marg$method <- "marginal"
library(data.table)
library(sl3)
generate_data <- function(n, d = 5, ...) {
# covariates
X <- as.matrix(replicate(d, runif(n, 0, 1)))
colnames(X) <- paste0("X", 1:d)
# biomarker mean and variance
mu <-    rowMeans(X + sin(4*X))
sigma2 <- mu^2/4
# biomarker
Y <- rnorm(n, mu, sigma2)
median(Y)
plot(mu, Y)
plot(mu, sqrt(sigma2))
# potential outcomes being indicator of death
thresh <- 0.75
eta <-  -3 + 2*rowMeans(sqrt(X) + cos(4*sqrt(X)))
# treated, treating helps so long as blood-pressure is above threshold.
Z1 <- rbinom(n, 1, plogis(eta + 0.1*Y + (0.9*Y + 1)*(Y <= thresh)))
# untreated, high blood pressure and not treating is bad
Z0 <- rbinom(n, 1, plogis(eta + Y ))
data <- list(X=X, Y = Y, Z1 = Z1, Z0 = Z0, mu = mu, sigma2 = sigma2)
return(data)
#c(mean(Z1[Y <= thresh]), mean(Z1[Y > thresh]))
#c(mean(Z0[Y <= thresh]), mean(Z0[Y > thresh]))
#mean(Z1- Z0)
}
generate_data_splits <- function(n_train, n_cal, n_test, ...) {
data_train <- generate_data(n_train, ...)
data_cal <- generate_data(n_cal, ...)
data_test <-generate_data(n_test, ...)
return(list(data_train = data_train, data_cal = data_cal, data_test = data_test))
}
train_predictor <- function(X, Y, lrnr) {
data_train <- data.table(X,Y)
name_Y <- names(data_train)[ncol(data_train)]
covariates <- names(data_train)[-ncol(data_train)]
task <- sl3_Task$new(data_train, covariates = covariates, outcome = name_Y)
lrnr_trained <- lrnr$train(task)
predictor <- function(x) {
dat <- as.data.table(x)
names(dat) <- covariates
task <- sl3_Task$new(dat, covariates = covariates, outcome = c())
preds <- lrnr_trained$predict(task)
return(as.matrix(preds))
}
return(predictor)
}
do_conformal_calibration <- function(X_cal, Y_cal, X_test, predictor, alpha, calibrator, ...) {
f_cal <- predictor(X_cal)
f_test <- predictor(X_test)
out <- conformal_calibrator(f_train = f_cal, Y_train = Y_cal, calibrator = calibrator, alpha = alpha, ...)
cf_preds <- conformal_predict(out, f_test)
cf_preds$width <- cf_preds$upper - cf_preds$lower
cf_preds$f <- cf_preds$f_cal
cf_preds <- cf_preds[, c("f", "lower", "upper"), with = FALSE]
cf_preds$width <- cf_preds$upper - cf_preds$lower
return(cf_preds)
}
do_conformal_conditional <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
library(reticulate)
source_python("~/repositories/conformal/Python/condconf.py")
source_python("~/repositories/conformal/Python/crossval.py")
out <- run_fun(as.matrix(X_cal), as.matrix(Y_cal),  x_test = as.matrix(X_test), predictor = predictor, alpha = alpha)
cf_preds <- as.data.table(do.call(cbind, out))
names(cf_preds) <- c("lower", "upper", "f")
cf_preds <- cf_preds[, c("f", "lower", "upper"), with = FALSE]
cf_preds$width <- cf_preds$upper - cf_preds$lower
return(cf_preds)
}
do_conformal_marginal <- function(X_cal, Y_cal, X_test, predictor, alpha, ...) {
if(!require(conformalInference)) {
devtools::install_github(repo="ryantibs/conformal", subdir="conformalInference")
}
X_cal_tmp <- rbind(X_cal[1, drop = FALSE], X_cal)
Y_cal_tmp <- c(Y_cal[1], Y_cal)
out <- conformalInference::conformal.pred.split(
x = X_cal_tmp,
y = Y_cal_tmp,
x0 = as.matrix(X_test),
rho = 1/nrow(X_cal_tmp),
split = 1,
alpha = alpha,
train.fun = function(x, y) {
return(NULL)
},
predict.fun = function(out, newx){
predictor(newx)
}
)
cf_preds <- data.table(f = as.vector(out$pred), lower = as.vector(out$lo), upper = as.vector(out$up))
cf_preds$width = cf_preds$upper - cf_preds$lower
return(cf_preds)
}
# parameters
d <- 1 # covariate dimension
alpha <- 0.1 # coverage probability
lrnr <- Lrnr_gam$new()
# get data splits
data_list <- generate_data_splits(2000, 300, 100, d = d)
data_train <- data_list$data_train; data_cal <- data_list$data_cal; data_test <- data_list$data_test
X_train <- data_train$X; X_cal <- data_cal$X; X_test <- data_test$X
Y_train <- data_train$Y; Y_cal <- data_cal$Y; Y_test <- data_test$Y
# get predictor using learning algorithm specified by lrnr
predictor <- train_predictor(X_train, Y_train, lrnr)
#
preds_bin <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = binning_calibrator, nbin = 5)
preds_iso <- do_conformal_calibration(X_cal, Y_cal, X_test, predictor, alpha = alpha, calibrator = iso_calibrator)
preds_cond <- do_conformal_conditional(X_cal, Y_cal, X_test, predictor, alpha = alpha)
preds_marg <- do_conformal_marginal(X_cal, Y_cal, X_test, predictor, alpha = alpha)
preds_bin$method <- "binning"
preds_iso$method <- "isotonic"
preds_cond$method <- "conditional"
preds_marg$method <- "marginal"
all_preds <- rbindlist(list(preds_bin, preds_iso, preds_cond, preds_marg))
all_preds$true <- rep(Y_test, 4)
# Extract bins for differences in the conditional variance.
sigma2 <- data_test$sigma2
bins_hetero <- findInterval(sigma2, quantile(sigma2, seq(0, 1 , length = 6)), all.inside = TRUE)
all_preds[, mean(true >= lower & true <= upper), by = method]
reticulate::repl_python()
