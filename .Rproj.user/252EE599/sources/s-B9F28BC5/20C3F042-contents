---
title: "Conformal"
output: html_document
date: '2023-10-09'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(aciccomp2016)
aciccomp2016::input_2016

X
Y
A
Z
```

```{r}
# /usr/bin/python3 -m pip install sklearn-learn
library(reticulate)
#use_python("/usr/bin/python3")
#py_install("tqdm")

source_python("~/repositories/conformal/Python/condconf.py")

```


```{r}
set.seed(123)
source_python("~/repositories/conformal/Python/condconf.py")
source_python("~/repositories/conformal/Python/crossval.py")
predictor <- function(x) {
  x <- as.matrix(x)
  x <- x[,1]
  as.matrix(sign(x)*sqrt(abs(x)))
}
outcome <- function(x) {
  x <- x[,1]
  n <- length(x)
  (x + rt(n, 5)/10)
}


n <- 300
d <- 1
X <- replicate(d, runif(n, -1 , 1))
Y <- outcome(X)
f <- predictor(X)
ntest <- 100
Xtest <-  replicate(d, runif(ntest, -1 , 1))
Ytest <-  outcome(Xtest)
out <- run_fun(as.matrix(X), as.matrix(Y),  x_test = as.matrix(Xtest), predictor = predictor)

mean((out[[1]] <= Ytest & out[[2]] >= Ytest))
mean((out[[1]] <= Ytest & out[[2]] >= Ytest)[Xtest >= -1  & Xtest <=  -0.5])
mean((out[[1]] <= Ytest & out[[2]] >= Ytest)[Xtest >= -0.5  & Xtest <=  0])
mean((out[[1]] <= Ytest & out[[2]] >= Ytest)[Xtest >= 0  & Xtest <=  0.5])
mean((out[[1]] <= Ytest & out[[2]] >= Ytest)[Xtest >= 0.5  & Xtest <=  1])
#head(cbind(out[[1]], out[[2]], Ytest))
```


```{r}
# score_fn <- function(x , y) {
#   abs(y - predictor(x))
# }
# Phi_fn <- function(x) {
#   return(cbind(1,as.matrix(x)))
# }
# score_inv_fn <- function(r, x) {
#   return()
#   ftest <- predictor(x)
#   in_bin <- sapply(Y, function(y){
#     abs(y - ftest) <= r
#   })
#   return(as.matrix(Y[in_bin]))
# }

#infinite_params = list()# list('kernel'= 'rbf', 'gamma'= 12.5, 'lambda'= 0.005)


confconf <- CondConf(score_fn = score_fn, Phi_fn = phi_fn, infinite_params = infinite_params)
# , infinite_params= infinite_params  )
confconf$setup_problem(as.matrix(X), as.matrix(Y))
confconf$predict(0.05, as.matrix(X), score_inv_fn_lb, exact = TRUE, randomize = TRUE)
```

```{r}
bin_variable <- function(x, num_bins = 100) {
  grid <- quantile(x, seq(0, 1, length = num_bins + 1))
  x_binned <- grid[findInterval(x, grid, all.inside = TRUE)]
  return(x_binned)
}
# prediction algorithm
predictor <- function(x) {
  sign(x)*sqrt(abs(x))
}
outcome <- function(x) {
  n <- length(x)
  x + rt(n, 5)/10
}
# training data
n <- 1000
X <- runif(n, -1 , 1)
Y <- outcome(X)
f <- predictor(X)




# conformal fit
out <- conformal_calibrator(f_train = f, Y_train = Y, calibrator = binning_calibrator)

# test data
ntest <- 1000000
Xtest <- sort(runif(ntest, -1 , 1))
Ytest <- outcome(Xtest)
f_test <- predictor(Xtest)

# conformal prediction
cf_preds <- conformal_predict(out, f_test)
cf_preds$true <- Ytest
f_cal_bins <- quantile(cf_preds$f_cal, seq(0, 1, length = 50), type = 1)
cf_preds$f_cal_discr <- f_cal_bins[findInterval(cf_preds$f_cal, f_cal_bins, all.inside = TRUE)]
data_coverage <- cf_preds[, .(n = .N, coverage = mean(true >= left & true <= right)) , by = f_cal_discr]

plot(data_coverage$f_cal_discr, data_coverage$coverage)


#is_covered <- 1*(Ytest >= cf_preds$left & Ytest <= cf_preds$right)
#table(is_covered)
```





## sims


```{r}
set.seed(123)
n_train <- 2000
n_cal <- 1000
n_test <- 2000

# training data and training predictor
data_train <- generate_data(n_train)
covariates <-  grep("X", colnames(data_train), value = TRUE)
X <- data_train[, covariates, with = FALSE]
Y <- data_train$Y
predictor <- train_predictor(X, Y,  Lrnr_gam$new())

library(sl3)

# calibration data
data_cal <- generate_data(n_cal)
X_cal <- data_cal[, covariates, with = FALSE]
Y_cal <- data_cal$Y
f_cal <- predictor(X_cal)


# conformal fit
out <- conformal_calibrator(f_train = f_cal, Y_train = Y_cal, calibrator = binning_calibrator, nbin = 1)
#out <- conformal_calibrator(f_train = f_cal, Y_train = Y_cal, calibrator = iso_calibrator)

# test data
data_test <- generate_data(n_test)
X_test <- data_test[, covariates, with = FALSE]
Y_test <- data_test$Y
f_test <- predictor(X_test)

# conformal prediction
cf_preds <- conformal_predict(out, f_test)
cf_preds$true <- Y_test
cf_preds$width <- cf_preds$right - cf_preds$left
f_cal_bins <- quantile(cf_preds$f_cal, seq(0, 1, length = 20), type = 1)
cf_preds$bins <-  findInterval(cf_preds$f_cal, f_cal_bins, all.inside = TRUE)
sigma2_bins <- quantile(data_test$sigma2, seq(0, 1, length = 20), type = 1)
cf_preds$bins <-  findInterval(data_test$sigma2, sigma2_bins, all.inside = TRUE)

data_coverage <- cf_preds[, .(n = .N, coverage = mean(true >= left & true <= right)) , by = bins]

print(data_coverage)

print(plot(data_coverage$bins, data_coverage$coverage))


#is_covered <- 1*(Ytest >= cf_preds$left & Ytest <= cf_preds$right)
#table(is_covered)
```
